---
layout: post
title:  "TCP/IP通信的三次握手和四次挥手"
date:   2019-05-15 11:31:00
categories: [计算机网络]
tags: [TCP]
comments: true
---

TCP和UDP都属于传输层的协议

<!--more-->
### TCP和UDP

<img src="/image/posts/blog1601.jpg" style="display:block;margin:0 auto;"> 

#### TCP
* 传输控制协议
* 传输过程是一对一的，一个客户端对应一个服务端建立连接；
* 面向连接，双方握手之后建立连接，才能发生请求与响应，请求结束之后必须要通过挥手断开连接；
* 实现可靠的传输，通过TCP传输的数据可靠、无差错、不重复、并且按序到达；
* 首部较长，20字节
* TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP的两端都有发送缓存和接收缓存。
* TCP并不关心应用程序一次把多长的报文发送到TCP的缓存中，而是根据对方给出的窗口值和当前网络的拥塞情况来决定一条报文段应包含多少字节
* HTTP请求传输使用TCP协议

#### UDP
* 用户报文协议
* UDP支持一对一，一对多，多对一，多对多的交互通信
* 不建立连接也可以发送传输数据，传输完成之后也不需要断开连接；
* 尽可能交付，但不能保证可靠传输
* 首部较短，8个字节
* UDP是面向报文的。发送方对应用程序交下来的报文，在添加首部之后就向下交付IP层。UDP对应用层交下来的报文既不合并也不拆分，而是保留这些报文的边界。也就是说应用层交付多长的报文，UDP就照样发送，即一次发送一个报文。
* UDP发送的报文程度应该是应用进程给出的。UDP没有拥塞控制 这样网络出现拥塞不会使源主机的发送速率降低。允许网络在拥塞时丢失一些数据的应用是可以的。
* DNS使用UDP协议

#### 如何实现拥塞控制
某一时间对网络带宽或缓存请求的需求超过了可用范围，就会发生拥塞，网络性能变差，因此需要放置过多的数据注入到网络通道，导致网络过载，这个过程叫做拥塞控制。

#### TCP如何保证可靠传输
* 应用数据被分割成TCP认为最适合发送的数据块。 
* 超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 
* TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 
* 校验和：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 
* TCP的接收端会丢弃重复的数据。 
* 流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。 
* 拥塞控制：当网络拥塞时，减少数据的发送。

### TCP标志字符：
-  `序列号seq`：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。

- `确认号ack`：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。

- `确认序号ACK`：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效

- `同步SYN`：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。

- `终止FIN`：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接

字段 |  含义
-------|--------
URG  | 紧急指针是否有效。为1，表示某一位需要被优先处理
ACK  | 确认号是否有效，为1时确认有效
PSH  | 提示接收端应用程序立即从TCP缓冲区把数据读走
RST  | 对方要求重新建立连接，复位
SYN  | 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1
FIN  | 发送端完成发送任务，希望断开连接

*注：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。*

*因为SYN需要占据一个字节的序列号空间，因此ACK中确认号ack为发来的SYN序列号seq加1（`ack = seq + 1`）；类似，FIN的ACK确认号为该FIN序列号加1。*

### 三次握手:建立连接协议

<img src="/image/posts/blog1602.png" style="display:block;margin:0 auto;"> 

* 第一次握手：客户端发送一个SYN=1包（SYN包）给服务端seq=x序号，表示新建连接请求
* 第二次握手：服务端接受报文之后，传输一个SYN=1的报文（SYN-ACK包）给客户端，ack=x+1，seq=y
* 第三次握手：客户端接收到报文之后，传输一个ACK=1（ACK包），seq=x+1，ack=y+1给服务端，表示连接建立，握手结束

##### 为什么三次握手?

**防止已过期的连接请求报文突然又传送的服务器，因而造成错误**

三次握手这个过程捋一遍:第一次握手后，server可以确认自己收报文与client发报文的功能都正常，而client呢，它什么都不能确认；第二次握手后，client可以确认自己的收发报文与server的收发报文功能都正常，也就是认为连接已建立；第三次，server也可以确认双方能够正常通信。

3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

**为什么不能用两次握手进行连接？** `这主要是为了防止已失效的请求连接报文忽然又传送到了，从而产生错误。`

假定A向B发送一个连接请求，由于一些原因，导致A发出的连接请求在一个网络节点逗留了比较多的时间。此时A会将此连接请求作为无效处理 又重新向B发起了一次新的连接请求，B正常收到此连接请求后建立了连接，数据传输完成后释放了连接。如果此时A发出的第一次请求又到达了B，B会以为A又发起了一次连接请求，如果是两次握手：此时连接就建立了，B会一直等待A发送数据，从而白白浪费B的资源。 如果是三次握手：由于A没有发起连接请求，也就不会理会B的连接响应，B没有收到A的确认连接，就会关闭掉本次连接。

**总结：**建立三次握手主要是因为client发送了再一次的确认，那么client为什么会再确认一次呢，主要是为了防止已失效的连接请求报文段又突然传送给server，从而产生了错误。
所谓“已失效的连接请求报文”是这样产生的，正常情况下，client发出连接请求，但是因为连接报文请求丢失而未收到确认，于是client再重传一次连接请求，后来收到了请求，并收到了确认，建立了连接，数据传输完毕后，就释放链接，client共发送了两次连接请求报文段，其中第一个丢失，第二个到达了B，没有“已失效的连接请求报文段”，但是还有异常情况下，client发送的请求报文连接段并没有丢失，而是在某个网络节点滞留较长时间，以致延误到请求释放后的某个时间到达server，本来是一个早已失效的报文段，但是server收到了此失效连接请求报文段后，就误以为client又重新发送的连接请求报文段，并发送确认报文段给client，同意建立连接，如果没有三次握手，那么server发送确认后，连接就建立了，而此时client没有发送建立连接的请求报文段，于是不理会server的确认，也不会给server发送数据，而server却一直等待client发送数据，因此server的许多资源就浪费了，采用三次握手的方式就可以防止这种事情发生，例如刚刚，client不理会server，就不会给server发送确认，server收不到client的确认，就知道client不要求建立连接，就不会白白浪费资源。

就好比打电话， A打给B， A要告诉B ，我打给你了， B要回应给A听，OK，连接成功了；然后B也要得到A的确认，才能开始正式通话

### 四次挥手:连接终止协议

<img src="/image/posts/blog1603.png" style="display:block;margin:0 auto;"> 

<img src="/image/posts/blog1604.png" style="display:block;margin:0 auto;"> 

* 第一次挥手：客户端发送一个FIN=1的断开连接的TCP报文给服务端，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），用来关闭Client到Server的数据传送，表示客户端不会再发送请求给服务端了。客户端进入FIN-WAIT-1（终止等待1）状态
* 第二次挥手：服务端收到FIN包之后会返回一个ACK包给服务端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），表示确认连接。Server进入CLOSE_WAIT状态。
* 第三次挥手：服务端发送FIN包给客户端，用来关闭Server到Client的数据传送，表示连接断开请求，表示服务端不会再发送请求给客户端了。Server进入LAST_ACK状态。
* 第四次挥手：客户端收到FIN之后，Client进入TIME_WAIT状态，接着发送ACK包给服务端，确认序号为收到序号+1，表示连接断开。服务器收到ACK包之后断开连接，Server进入CLOSED状态，完成四次挥手。

### 常见面试题

- **1.为什么连接的时候是三次握手，关闭的时候却是四次握手？**
答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

- **2.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**
答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

- **3.如果已经建立了连接，但是客户端突然出现故障了怎么办？**

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。